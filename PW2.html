<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Three.js - Basic Cube</title>
    <style>
      html,
      body {
        width: 50%;
        height: 50%;
        margin: 0;
      }

      #c {
        width: 50%;
        height: 50%;
        display: block;
      }
    </style>
  </head>
  <body>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
      }
    }
  </script>

<script type="module">
    import * as THREE from 'three';
    // import { TextGeometry } from '/three/examples/jsm/geometries/TextGeometry.js';
    // import { FontLoader } from '/three/examples/jsm/loaders/FontLoader.js';
    import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/geometries/TextGeometry.js';
    import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/FontLoader.js';
    import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
    import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    

        var scene = new THREE.Scene();
        var renderer = new THREE.WebGLRenderer();
        // console.log(renderer.context);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // make shadow soft
        document.body.appendChild(renderer.domElement);      
        
        // light
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 5);
        light.castShadow = true;
        light.shadow.mapSize.width = 2048;
        light.shadow.mapSize.height = 2048;
        light.shadow.radius = 5;
        scene.add(light);

        // PerspectiveCamera
        var aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        camera.position.set(0, 0, 5);
        const controls = new OrbitControls(camera, renderer.domElement);

        
        //////////////////////////////////////////////////////////////////////////////////////////////
        // Functions
        //////////////////////////////////////////////////////////////////////////////////////////////
        function mark_closs(x, y, z){
            const material = new THREE.LineBasicMaterial( { color: 0x808080 } );
            const points = [];
            points.push( new THREE.Vector3( - 0.1, 0, 0 ) );
            // points.push( new THREE.Vector3( 0, 10, 0 ) );
            points.push( new THREE.Vector3( 0.1, 0, 0 ) );

            const geometry = new THREE.BufferGeometry().setFromPoints( points );
            const line_x = new THREE.Line( geometry, material );
            const line_y = new THREE.Line( geometry, material );
            line_x.position.set(x, y, z);
            line_y.position.set(x, y, z);
            line_y.rotation.y = Math.PI / 2;
            scene.add( line_x );
            scene.add( line_y );
        }
        function set_cross(){
            const x = 0
            const y = 0
            const z = 0
            for ( let x = -10; x < 10; x += 5 ) {
            for ( let z = -10; z < 10; z += 5 ) {
                mark_closs(x, y, z);
            }
            }
        }
        
        


        //////////////////////////////////////////////////////////////////////////////////////////////
        // Modeling
        //////////////////////////////////////////////////////////////////////////////////////////////

        // materials
        // const matA = new THREE.MeshStandardMaterial({ color: 0x505050 }); // dark gray color
        // const matA = new THREE.MeshStandardMaterial({ color: 0x808080 }); // light gray color
        const mat_white = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, //white
            roughness: 0.3,
            metalness: 0.0,
        });
        const mat_lightGray = new THREE.MeshStandardMaterial({ 
            color: 0x808080, // light gray color
            roughness: 0.3,
            metalness: 0.2,
        });
        const mat_left = new THREE.MeshLambertMaterial()
        const mat_center = new THREE.MeshPhysicalMaterial()
        const mat_right = new THREE.MeshPhongMaterial()

        // table
        const g_plate = new THREE.BoxGeometry(1.6, 1, 0.02);
        const p_plate = new THREE.Mesh(g_plate, mat_white);
        const g_leg = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 5);
        const p_leg = new THREE.Mesh(g_leg, mat_white);
        const table = new THREE.Object3D();
        const p_leg1 = p_leg.clone()
        const p_leg2 = p_leg.clone()
        p_plate.position.set(0, 0.7, 0); 
        p_plate.rotation.x = Math.PI / 2;
        p_leg1.position.set(0.65, 0.35, 0);
        p_leg2.position.set(-0.65, 0.35, 0);
        table.add(p_plate);
        table.add(p_leg1);
        table.add(p_leg2)
        table.castShadow = true;
        table.rotation.y = Math.PI / 2
        table.position.set(0, 0, 2)

        const tables = new THREE.Object3D();
        tables.add(table)

        const table2 = table.clone()
        table2.position.set(0, 0, 2-0.8*2)
        tables.add(table2)

        const table3 = table.clone()
        table3.position.set(0, 0, 2-(0.8*2)*2)
        tables.add(table3)

        const table4 = table.clone()
        table4.position.set(0, 0, 2-(0.8*2)*3)
        tables.add(table4)

        const tables1 = tables.clone()
        tables1.position.set(2, 0, 0)
        scene.add(tables1)
        const tables2 = tables.clone()
        tables2.position.set(-2, 0, 0)
        scene.add(tables2)

        const table5 = table.clone()
        table5.rotation.y = Math.PI 
        table5.position.set(-0.8, 0, 2-(0.8*2)*3-0.3)
        scene.add(table5)
        const table6 = table.clone()
        table6.rotation.y = Math.PI 
        table6.position.set(0.8, 0, 2-(0.8*2)*3-0.3)
        scene.add(table6)

        // chair
        const chair = new THREE.Object3D();
        const g_plate_c = new THREE.BoxGeometry(0.5, 0.05, 0.5);
        const p_plate_c = new THREE.Mesh(g_plate_c, mat_lightGray);
        const p_plate2_c = p_plate_c.clone()
        const g_leg_c = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 5);
        const p_leg_c = new THREE.Mesh(g_leg_c, mat_white);
        const p_leg1_c = p_leg_c.clone()
        const p_leg2_c = p_leg_c.clone()
        const p_leg3_c = p_leg_c.clone()
        const p_leg4_c = p_leg_c.clone()
        p_plate_c.position.set(0, 0.5, 0); 
        p_plate2_c.rotation.z = Math.PI / 2;
        p_plate2_c.rotation.y = Math.PI / 2;
        p_plate2_c.position.set(0, 0.7, 0.25)
        p_leg1_c.position.set(0.24, 0.25, 0.24);
        p_leg2_c.position.set(-0.24, 0.25, 0.24);
        p_leg3_c.position.set(0.24, 0.25, -0.24);
        p_leg4_c.position.set(-0.24, 0.25, -0.24);
        chair.add(p_plate_c);
        chair.add(p_plate2_c);
        chair.add(p_leg1_c);
        chair.add(p_leg2_c)
        chair.add(p_leg3_c);
        chair.add(p_leg4_c)
        chair.castShadow = true;
        chair.rotation.y = Math.PI / 2

        const chairs = new THREE.Object3D();
        const chair1 = chair.clone()
        chair1.position.set(0, 0, 0)
        chairs.add(chair1)
        const chair2 = chair.clone()
        chair2.position.set(0, 0, -1.0)
        chairs.add(chair2)
        const chair3 = chair.clone()
        chair3.position.set(0, 0, -1.0*2+0.2)
        chairs.add(chair3)
        const chair4 = chair.clone()
        chair4.position.set(0, 0, -1.0*3+0.1)
        chairs.add(chair4)
        const chair5 = chair.clone()
        chair5.position.set(0, 0, -1.0*4)
        chairs.add(chair5)
        chairs.position.set(2.5, 0, 2)
        scene.add(chairs)
        const chairs2 = chairs.clone()
        chairs2.rotation.y = Math.PI
        chairs2.position.set(-2.5, 0, -2)
        scene.add(chairs2)

        const chair6 = chair.clone()
        chair6.position.set(-1.5, 0, -3.5)
        chair6.rotation.y = Math.PI 
        scene.add(chair6)
        const chair7 = chair.clone()
        chair7.position.set(1, 0, -3.5)
        chair7.rotation.y = Math.PI 
        scene.add(chair7)

        // floor
        const g_floor = new THREE.BoxGeometry(7, 0.3, 10);
        const p_floor = new THREE.Mesh(g_floor, mat_lightGray);
        const floor = new THREE.Object3D();
        floor.add(p_floor)
        floor.position.set(0, -0.15, 0); 
        floor.receiveShadow = true;
        scene.add(floor)

        // wall1
        const g_wall1 = new THREE.BoxGeometry(3, 0.05, 10);
        const p_wall1 = new THREE.Mesh(g_wall1, mat_white);
        const wall1 = new THREE.Object3D();
        wall1.add(p_wall1) 
        const wall1_1 = wall1.clone()
        wall1_1.rotation.z = Math.PI / 2
        wall1_1.position.set(-3.5, 1.5, 0); 
        wall1_1.receiveShadow = true;
        scene.add(wall1_1)
        const wall1_2 = wall1_1.clone()
        wall1_2.rotation.z = Math.PI / 2
        wall1_2.position.set(3.5, 1.5, 0); 
        wall1_2.receiveShadow = true;
        scene.add(wall1_2)

        // wall2
        const g_wall2 = new THREE.BoxGeometry(7, 0.05, 3);
        const p_wall2 = new THREE.Mesh(g_wall2, mat_white);
        const wall2 = new THREE.Object3D();
        wall2.add(p_wall2) 
        wall2.rotation.x = Math.PI / 2
        wall2.position.set(0, 1.5, -5)
        scene.add(wall2)

        const g_leftCone = new THREE.ConeGeometry(0.3, 0.5, 10)
        const leftCone = new THREE.Mesh(g_leftCone, mat_left)
        // const leftCone = new THREE.Object3D();
        // leftCone.add(p_leftCone)
        leftCone.position.set(-1.5, 0.7+0.25, 2-(0.8*2)*3-0.3)
        scene.add(leftCone)

        !!!! git kaiketsu





        //////////////////////////////////////////////////////////////////////////////////////////////
        // Rendrer
        //////////////////////////////////////////////////////////////////////////////////////////////
        // scene.background = new THREE.Color(0xffffff); // Set background to white
        function render (time) {
            set_cross();
            requestAnimationFrame(render);
            renderer.render(scene, camera);
            controls.update();
        };
        render();
        

    </script>
  </body>
</html>
