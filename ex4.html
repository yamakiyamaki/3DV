<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Three.js - Basic Cube</title>
    <style>
      html,
      body {
        width: 50%;
        height: 50%;
        margin: 0;
      }

      #c {
        width: 50%;
        height: 50%;
        display: block;
      }
    </style>
  </head>
  <body>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
      }
    }
  </script>

<script type="module">
  import * as THREE from 'three';
  // import { TextGeometry } from '/three/examples/jsm/geometries/TextGeometry.js';
  // import { FontLoader } from '/three/examples/jsm/loaders/FontLoader.js';
  import { TextGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/geometries/TextGeometry.js';
  import { FontLoader } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/loaders/FontLoader.js';
  import { ParametricGeometry } from 'three/addons/geometries/ParametricGeometry.js';
  import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  

        var scene = new THREE.Scene();
        // var aspect = window.innerWidth / window.innerHeight;
        // var camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        // camera.position.set(50, 50, 50); // (X, Y, Z)
        // camera.lookAt(0, 0, 0); // シーンの中心を注視
        var renderer = new THREE.WebGLRenderer();
        // console.log(renderer.context);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // // show image
        // var geometry = new THREE.BoxGeometry(0, 2, 1);
        // const textureLoader = new THREE.TextureLoader();
        // const texture = textureLoader.load("https://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/Gorille_des_plaines_de_l%27ouest_%C3%A0_l%27Espace_Zoologique.jpg/440px-Gorille_des_plaines_de_l%27ouest_%C3%A0_l%27Espace_Zoologique.jpg");
        // const material = new THREE.MeshBasicMaterial({ map: texture });
        // var image = new THREE.Mesh(geometry, material);
        // image.position.set(0, 1, 1);
        // scene.add(image);

        
        
        function mark_closs(x, y, z){
          const material = new THREE.LineBasicMaterial( { color: 0x808080 } );
          const points = [];
          points.push( new THREE.Vector3( - 0.5, 0, 0 ) );
          // points.push( new THREE.Vector3( 0, 10, 0 ) );
          points.push( new THREE.Vector3( 0.5, 0, 0 ) );

          const geometry = new THREE.BufferGeometry().setFromPoints( points );
          const line_x = new THREE.Line( geometry, material );
          const line_y = new THREE.Line( geometry, material );
          line_x.position.set(x, y, z);
          line_y.position.set(x, y, z);
          line_y.rotation.y = Math.PI / 2;
          scene.add( line_x );
          scene.add( line_y );
        }
        function set_cross(){
          const x = 0
          const y = 0
          const z = 0
          for ( let x = -50; x < 50; x += 5 ) {
            for ( let z = -50; z < 50; z += 5 ) {
              mark_closs(x, y, z);
            }
          }
        }
        
        // PerspectiveCamera
        var aspect = window.innerWidth / window.innerHeight;
        var camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        camera.position.set(30, 30, 30); // (X, Y, Z)
        camera.lookAt(0, 0, 0); // シーンの中心を注視

        // OrthographicCamera
        const left = -50;
        const right = 50;
        const top = 50;
        const bottom = -50;
        const near = 10;
        const far = 50;
        const camera2 = new THREE.OrthographicCamera(left, right, top, bottom, near, far);
        camera2.zoom = 0.2;
        camera2.position.set(10, 30, 50);
        camera2.lookAt(0, 20, 0); 

      
        // camera control
        // // Initialize FirstPersonControls
        // const FPcontrol = new FirstPersonControls(camera, renderer.domElement);
        // FPcontrol.movementSpeed = 10; // Speed of movement
        // FPcontrol.lookSpeed = 0.1; // Speed of looking around
        // FPcontrol.lookVertical = true; 
        // FPcontrol.handleResize();

        // // Initialize OrbitControls
        // const OBcontrol = new OrbitControls( camera2, renderer.domElement );

        // const clock = new THREE.Clock();
        
        let currentCamera = camera;
        // let currentControl = FPcontrol;
        window.addEventListener("keydown", (event) => {
          if (event.key === "c") {
              currentCamera = currentCamera === camera ? camera2 : camera;
            //   currentControl = currentControl === FPcontrol ? OBcontrol : FPcontrol;
              console.log("Camera switched");
          }
        });

        

        // materials
        const material = new THREE.MeshNormalMaterial();

        // // geometries and meshs
        // const geometry1 = new THREE.BoxGeometry(10, 3, 3)
        // const mesh1 = new THREE.Mesh(geometry1, material);
        // mesh1.position.set(0, 0, 0); // Position on X-axis
    
        // const geometry2 = new THREE.BoxGeometry(10, 3, 3)
        // const mesh2 = new THREE.Mesh(geometry2, material);
        // mesh2.position.set(5, 5, 0); // Position on X-axis
        // mesh2.rotation.set(0, 0, (Math.PI / 2)); // Rotation on X-axis

        // const geometry3 = new THREE.BoxGeometry(10, 3, 3)
        // const mesh3 = new THREE.Mesh(geometry3, material);
        // mesh3.position.set(5, 0, 0); // Position on X-axis

        // const group = new THREE.Group();
        // group.add(mesh1);
        // group.add(mesh2);

        // const pivot = new THREE.Object3D();
        // scene.add(pivot);
        // pivot.position.set(5, 0, 0);
        // pivot.add(mesh2);
        
        // group.position.set(0, 30, 0); // Position on X-axis 
        // scene.add(group); 

        const geomA = new THREE.BoxGeometry(10, 10, 10);
        const matA = new THREE.MeshNormalMaterial();
        const partA = new THREE.Mesh(geomA, matA);

        const geomB = new THREE.CylinderGeometry(5, 5, 10, 10);
        const matB = new THREE.MeshNormalMaterial();
        const partB = new THREE.Mesh(geomB, matB);

        // create C(=A+B)
        const partC = new THREE.Object3D();
        partA.position.set(0, 0, 0); 
        partB.position.set(7, 0, 0); 
        partC.add(partA);
        partC.add(partB);

        const C1 = partC.clone();
        const C2 = partC.clone();

        // create pivot
        const P1 = new THREE.Object3D();
        scene.add(P1);

        const P2 = new THREE.Object3D();
        P1.add(P2);
        // scene.add(P2);

        P1.add(C1);
        C1.position.set(0, 0, 0);

        P2.add(C2);
        C2.position.set(5, 0, 0); // How much the pivot is shifted from the center of the object
        P2.position.set(7.5, 0, 0); //How much the object is shifted from the postition       
        
        // scene.background = new THREE.Color(0xffffff); // Set background to white
        function render (time) {
            set_cross();
            requestAnimationFrame(render);
            
            // currentControl.update(clock.getDelta());
            console.log('camera1');
            renderer.render(scene, currentCamera);
    
            // cube.rotation.x += 0.1;
            // cube.rotation.y += 0.1; 
            time *= 0.001; 
            const rot = 1 * time;
            // group.rotation.x = rot;
            // group.rotation.y = rot;
            // mesh1.rotation.x = rot;

            // pivot.rotation.z += 0.1;

            // C1.rotation.z = Math.sin(Date.now() * 0.001) * 0.5;
            P1.position.z += 0.1; 
            P2.rotation.y = Math.sin(Date.now() * 0.001 + Math.PI / 2) * 0.5;
          
        };
        render();
        

    </script>
  </body>
</html>
